import axios from 'axios';
import fs from 'fs';
import * as cheerio from 'cheerio';
import * as readline from 'readline';


async function writeToFile(aspirations: string[]) {
  const file =
    '// This file is automatically generated by the crawlAspirations script.\n' +
    '// Do not edit this file directly.\n\n' +
    'const ASPIRATIONS = [\n' +
    aspirations.map((aspiration) => `  '${aspiration}',`).join('\n') +
    '\n] as const;\n\n' +
    'type Aspiration = typeof ASPIRATIONS[number];\n\n\n' +
    'export {\n' +
    '  Aspiration,\n' +
    '  ASPIRATIONS,\n' +
    '};\n';

  fs.writeFileSync('src/common/scripts/aspirations.ts', file);

  console.log('Changes written to file.');
}


async function main()  {
  const url = 'https://sims.fandom.com/wiki/Aspiration_(The_Sims_4)';

  const response = await axios.get(url);
  const html = response.data;
  const $ = cheerio.load(html);

  let aspirations: string[] = [];

  // Log CWD
  console.log(`CWD: ${process.cwd()}`);

  // Select the relevant section of the page
  const section = $('h2:contains("List of aspirations")')
      .nextUntil('h2:contains("Gallery")')
      .filter('table');

  const sectionElements = section
      .find('td:nth-child(2)')  // Make sure we're not looking at the single column header
      .siblings('td:first-child')  // Select the aspiration column
      .find('> b');  // Select the bolded text (the aspiration names)

  // Collect aspiration names
  for (let element of sectionElements) {
    aspirations.push($(element).text().trim());
  }

  console.log(`Found ${aspirations.length} aspirations on the wiki page.`);

  // Compare with existing list
  const existingAspirationsFile = fs
      .readFileSync('src/common/scripts/aspirations.ts', 'utf8')
      .match(/const ASPIRATIONS = \[[^;\]]+] as const;/);

  if (!existingAspirationsFile || existingAspirationsFile.length === 0) {
    throw new Error('Could not find existing aspirations file or the format does not match.');
  }

  const existingAspirations = existingAspirationsFile[0]
    ?.match(/'.+',\n/g)
    ?.map((aspiration) => aspiration.slice(1, aspiration.length - 3).trim())
    .flat();

  if (!existingAspirations) {
    throw new Error('Could not parse existing aspirations from file.');
  }

  console.log(`Found ${existingAspirations.length} aspirations in the aspirations file.`);

  // Log the differences
  aspirations = aspirations.map((aspiration) => aspiration.replace('\'', '\\\''));
  aspirations.sort();
  existingAspirations.sort();

  let changesFound = false;
  let i = 0;
  let j = 0;

  while (i < existingAspirations.length && j < aspirations.length) {
    if (existingAspirations[i] === aspirations[j]) {
      i++;
      j++;
    } else {
      changesFound = true;

      if (existingAspirations[i] < aspirations[j]) {
        console.log(`- ${existingAspirations[i]}`);
        i++;
      } else if (existingAspirations[i] > aspirations[j]) {
        console.log(`+ ${aspirations[j]}`);
        j++;
      }
    }
  }

  if (i < existingAspirations.length) {
    changesFound = true;
    console.log(`- ${existingAspirations.slice(i).join('\n- ')}`);
  } else if (j < aspirations.length) {
    changesFound = true;
    console.log(`+ ${aspirations.slice(j).join('\n+ ')}`);
  }

  if (!changesFound) {
    console.log('No changes found.');
    return;
  }

  // Ask if changes should be written
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });

  rl.question('Write changes to file? (y/n) ', (answer) => {
    if (answer === 'y') {
      console.log('Writing changes to file...');
      writeToFile(aspirations);
    } else {
      console.log('Changes not written to file.');
    }
    rl.close();
  });
}


main();
