import axios from 'axios';
import fs from 'fs';
import * as cheerio from 'cheerio';
import * as readline from 'readline';


async function writeToFile(traits: string[]) {
  const file =
    '// This file is automatically generated by the crawlTraits script.\n' +
    '// Do not edit this file directly.\n\n' +
    'const TRAITS = [\n' +
    traits.map((trait) => `  '${trait}',`).join('\n') +
    '\n] as const;\n\n' +
    'type Trait = typeof TRAITS[number];\n\n\n' +
    'export {\n' +
    '  Trait,\n' +
    '  TRAITS,\n' +
    '};\n';

  fs.writeFileSync('src/common/scripts/traits.ts', file);

  console.log('Changes written to file.');
}


async function getSimsTraits() {
  const url = 'https://sims.fandom.com/wiki/Trait_(The_Sims_4)';

  const response = await axios.get(url);
  const $ = cheerio.load(response.data);

  let traits: string[] = [];

  // Select the relevant section of the page
  const section = $('h2:contains("Personality traits")')
    .nextUntil('h2:contains("Others")')
    .filter('table');

  const sectionElements = section
    .find('td:nth-child(3)')  // Make sure we're looking at a complete table
    .siblings('td:nth-child(2)');  // Select the trait column

  const linkedTraits = sectionElements
    .children('a')
    .contents().filter((_, el) => el.type === "text");

  const unlinkedTraits = sectionElements
    .filter((_, el) => $(el).children('a').length === 0)
    .contents().filter((_, el) => el.type === "text");

  // Collect trait names
  for (let element of linkedTraits.add(unlinkedTraits)) {
    const text = $(element).text().trim();

    if (text.length === 0) {
      continue;
    }

    traits.push(text);
  }

  return traits;
}


async function getPetsTraits() {
  const url = 'https://sims.fandom.com/wiki/Pet_trait_(The_Sims_4)';

  const response = await axios.get(url);
  const $ = cheerio.load(response.data);

  let traits: string[] = [];

  // Select the relevant section of the page
  const section = $('h2:contains("List of pet traits")')
    .nextUntil('table.navbox')
    .filter('table');

  const sectionElements = section
    .find('td:nth-child(3)')  // Make sure we're looking at a complete table
    .siblings('td:nth-child(2)')  // Select the trait column
    .contents().filter((_, el) => el.type === "text");

  // Collect trait names
  for (let element of sectionElements) {
    const text = $(element).text().trim();

    if (text.length === 0) {
      continue;
    }

    traits.push(text);
  }

  return traits;
}


async function main()  {
  // Log CWD
  console.log(`CWD: ${process.cwd()}`);

  let traits = (await getSimsTraits()).concat(await getPetsTraits());

  console.log(`Found ${traits.length} traits on the wiki page.`);

  // Compare with existing list
  const existingTraitsFile = fs
    .readFileSync('src/common/scripts/traits.ts', 'utf8')
    .match(/const TRAITS = \[[^;\]]+] as const;/);

  if (!existingTraitsFile || existingTraitsFile.length === 0) {
    throw new Error('Could not find existing aspirations file or the format does not match.');
  }

  const existingTraits = existingTraitsFile[0]
    ?.match(/'.+',\n/g)
    ?.map((trait) => trait.slice(1, trait.length - 3).trim())
    .flat();

  if (!existingTraits) {
    throw new Error('Could not parse existing traits from file.');
  }

  console.log(`Found ${existingTraits.length} traits in the traits file.`);

  // Log the differences
  traits = traits
    .map((trait) => trait.replace('\'', '\\\''))
    .sort();
  traits = traits
    .filter((trait, idx) => traits.indexOf(trait) === idx);  // Remove duplicates
  existingTraits.sort();

  let changesFound = false;
  let i = 0;
  let j = 0;

  while (i < existingTraits.length && j < traits.length) {
    if (existingTraits[i] === traits[j]) {
      i++;
      j++;
    } else {
      changesFound = true;

      if (existingTraits[i] < traits[j]) {
        console.log(`- ${existingTraits[i]}`);
        i++;
      } else if (existingTraits[i] > traits[j]) {
        console.log(`+ ${traits[j]}`);
        j++;
      }
    }
  }

  if (i < existingTraits.length) {
    changesFound = true;
    console.log(`- ${existingTraits.slice(i).join('\n- ')}`);
  } else if (j < traits.length) {
    changesFound = true;
    console.log(`+ ${traits.slice(j).join('\n+ ')}`);
  }

  if (!changesFound) {
    console.log('No changes found.');
    return;
  }

  // Ask if changes should be written
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });

  rl.question('Write changes to file? (y/n) ', (answer) => {
    if (answer === 'y') {
      console.log('Writing changes to file...');
      writeToFile(traits);
    } else {
      console.log('Changes not written to file.');
    }
    rl.close();
  });
}


main();
